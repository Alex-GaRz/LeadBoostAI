import logging
from contextlib import asynccontextmanager
from fastapi import FastAPI, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware

# Internal Core Modules
from core.simulator_engine import EnterpriseSimulatorEngine
from core.event_bus import EventBus
from core.safety_engine import safety_engine
from core.distributed_lock import atomic_transaction
from api import routes

# Security Modules (RFC-PHOENIX-03)
from core.security import (
    secret_manager,
    sts_service,
    create_security_middleware,
    get_mtls_config,
    configure_uvicorn_ssl,
    iam_enforcer,
    audit_logger,
    get_security_context,
    SecurityContext,
    Permission,
    AuditEvent,
    AuditEventType,
    AuditSeverity
)

# Logging Setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("EnterpriseMain")

# --- LIFECYCLE MANAGEMENT ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("ðŸš€ Enterprise Nervous System: INITIALIZING...")
    
    # 0. Initialize Security Infrastructure
    logger.info("ðŸ” Initializing Security (RFC-PHOENIX-03)...")
    
    # Load IAM policies
    iam_enforcer.reload_policies()
    logger.info("âœ… IAM Policies loaded")
    
    # Initialize STS (Security Token Service)
    logger.info("âœ… Security Token Service initialized")
    
    # 1. Initialize Event Bus
    bus = EventBus()
    
    # 2. Start Safety Engine (The Listener)
    await safety_engine.start_surveillance()
    
    logger.info("âœ… Redis Connected & Safety Rules Active")
    logger.info("âœ… Enterprise System READY (Secure Mode)")
    
    yield
    
    # Shutdown
    logger.info("ðŸ›‘ Shutting down Enterprise System...")
    await bus.close()

app = FastAPI(
    title="LeadBoostAI - Block 11: Enterprise Nervous System",
    description="Reactive ERP with Distributed Locking & Kill Switch (Secure)",
    version="3.0.0",  # RFC-PHOENIX-03
    lifespan=lifespan
)

# Security Middleware (JWT Validation & Audit)
# NOTA: /sts/token ahora requiere autenticaciÃ³n (correcciÃ³n crÃ­tica del Auditor)
security_middleware = create_security_middleware(
    service_name="enterprise",
    exclude_paths=["/health", "/docs", "/openapi.json", "/redoc"]
)
app.middleware("http")(security_middleware)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Engine Singleton
engine = EnterpriseSimulatorEngine()

# --- ROUTES ---
app.include_router(routes.router, prefix="/enterprise", tags=["Enterprise ERP"])

# --- SECURITY TOKEN SERVICE ENDPOINTS ---
from fastapi import HTTPException, status, Depends
from pydantic import BaseModel
from typing import List

class TokenRequest(BaseModel):
    service_id: str
    client_secret: str  # En producciÃ³n: validar contra secreto real

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int = 900  # 15 minutos

@app.post("/sts/token", response_model=TokenResponse, tags=["Security"])
async def issue_service_token(req: TokenRequest):
    try:
            try:
                    """
                    Emite un token JWT para autenticaciÃ³n servicio-a-servicio.
                    CORRECCIÃ“N CRÃTICA: Ahora valida client_secret contra SecretManager.
                    Rechaza cualquier intento con credenciales invÃ¡lidas.
                    """
                    # VALIDACIÃ“N ESTRICTA DE CLIENT SECRET (CorrecciÃ³n Auditor #1)
                    expected_secret = secret_manager.get_secret(f"{req.service_id}_CLIENT_SECRET")
                    if not expected_secret:
                        # Secret no configurado para este servicio
                        audit_logger.log_event(AuditEvent(
                            event_type=AuditEventType.AUTH_TOKEN_INVALID,
                            actor=req.service_id,
                            action="request_token",
                            result="denied",
                            severity=AuditSeverity.WARNING,
                            details={"reason": "client_secret_not_configured"}
                        ))
                        logger.warning(f"â›” Token denegado: Secret no configurado para {req.service_id}")
                        raise HTTPException(
                            status_code=status.HTTP_401_UNAUTHORIZED,
                            detail="Service not configured or client_secret missing"
                        )
                    if req.client_secret != expected_secret:
                        # Client secret incorrecto
                        audit_logger.log_event(AuditEvent(
                            event_type=AuditEventType.AUTH_TOKEN_INVALID,
                            actor=req.service_id,
                            action="request_token",
                            result="denied",
                            severity=AuditSeverity.WARNING,
                            details={"reason": "invalid_client_secret"}
                        ))
                        logger.warning(f"â›” Token denegado: Client secret invÃ¡lido para {req.service_id}")
                        raise HTTPException(
                            status_code=status.HTTP_401_UNAUTHORIZED,
                            detail="Invalid client credentials"
                        )
                    # Cargar configuraciÃ³n del servicio
                    import yaml
                    from pathlib import Path
                    config_path = Path(__file__).parent.parent / "config" / "security" / "service_identities.yaml"
                    try:
                        with open(config_path, 'r') as f:
                            config = yaml.safe_load(f)
                        # Buscar servicio
                        service_config = next(
                            (s for s in config.get("services", []) if s["service_id"] == req.service_id),
                            None
                        )
                        if not service_config:
                            raise HTTPException(
                                status_code=status.HTTP_404_NOT_FOUND,
                                detail=f"Service ID desconocido: {req.service_id}"
                            )
                        # Emitir token
                        token = sts_service.issue_token(
                            service_id=req.service_id,
                            role=service_config["role"],
                            scopes=service_config["scopes"],
                            expiration_minutes=15
                        )
                        # Registrar en auditorÃ­a
                        audit_logger.log_token_issued(
                            service_id=req.service_id,
                            role=service_config["role"],
                            scopes=service_config["scopes"],
                            token_id="generated"
                        )
                        logger.info(f"ðŸŽ« Token emitido para: {req.service_id}")
                        return TokenResponse(
                            access_token=token,
                            expires_in=900
                        )
                    except FileNotFoundError:
                        raise HTTPException(
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Service configuration not found"
                        )
            except Exception as e:
                logger.warning(f"Intento de acceso fallido: {str(e)}")
                raise HTTPException(status_code=401, detail='Invalid credentials')
    except Exception as e:
        logger.warning(f"Intento de acceso fallido: {str(e)}")
        raise HTTPException(status_code=401, detail='Invalid credentials')
@app.get("/sts/jwks", tags=["Security"])
async def get_jwks():
    """
    JSON Web Key Set (JWKS) endpoint.
    Permite a otros servicios validar tokens sin consultar al STS.
    """
    return sts_service.get_public_keys()

@app.post("/sts/rotate-keys", tags=["Security"])
async def rotate_signing_keys(ctx: SecurityContext = Depends(get_security_context)):
    """
    Rota las claves de firma del STS.
    CORRECCIÃ“N CRÃTICA: Ahora requiere permisos de administrador.
    """
    
    # VALIDACIÃ“N DE PERMISOS DE ADMINISTRADOR (CorrecciÃ³n Auditor #2)
    has_admin_permission = iam_enforcer.check_permission(
        ctx.role,
        Permission.ADMIN_POLICIES
    )
    
    if not has_admin_permission:
        # Permiso denegado
        audit_logger.log_event(AuditEvent(
            event_type=AuditEventType.AUTHZ_PERMISSION_DENIED,
            actor=ctx.service_id,
            action="rotate_keys",
            result="denied",
            severity=AuditSeverity.WARNING,
            details={
                "required_permission": "ADMIN_POLICIES",
                "actor_role": ctx.role
            }
        ))
        logger.warning(f"â›” RotaciÃ³n de claves denegada: {ctx.service_id} no tiene permiso ADMIN_POLICIES")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions. ADMIN_POLICIES required."
        )
    
    # Obtener old_key_id antes de rotar
    old_key_id = sts_service._active_key_id
    
    # Rotar claves
    new_key_id = sts_service.rotate_keys()
    
    # Registrar en auditorÃ­a con IDs correctos
    audit_logger.log_key_rotation(
        old_key_id=old_key_id or "none",
        new_key_id=new_key_id
    )
    
    logger.info(f"ðŸ”„ Claves rotadas por {ctx.service_id}: {old_key_id} -> {new_key_id}")
    
    return {
        "status": "rotated",
        "old_key_id": old_key_id,
        "new_key_id": new_key_id,
        "rotated_by": ctx.service_id
    }

# --- EXAMPLE ENDPOINT TO TRIGGER REAL-TIME LOGIC ---
@app.post("/test/simulate-sale")
@atomic_transaction(lambda req, **kwargs: req["sku"])
async def simulate_atomic_sale(req: dict, background_tasks: BackgroundTasks):
    """
    Test endpoint to demonstrate:
    1. Distributed Lock (only one sale per SKU at a time)
    2. Event Publication
    3. Safety Engine Reaction
    """
    sku = req.get("sku")
    qty_sold = req.get("qty", 1)
    
    # 1. Update State (Critical Section protected by lock)
    product = engine.get_product(sku)
    if not product:
        return {"error": "SKU not found"}
    
    if product.qty < qty_sold:
        return {"error": "Insufficient stock"}
        
    product.qty -= qty_sold
    engine._save_state()
    
    # 2. Publish Event (Fire & Forget)
    bus = EventBus()
    background_tasks.add_task(
        bus.publish, 
        "enterprise.inventory_updates", 
        {"sku": sku, "qty": product.qty, "timestamp": "NOW"}
    )
    
    return {
        "status": "Sale Processed", 
        "remaining_stock": product.qty, 
        "lock_status": "Released"
    }

if __name__ == "__main__":
    import uvicorn
    
    # ConfiguraciÃ³n mTLS
    mtls_config = get_mtls_config("enterprise")
    ssl_params = configure_uvicorn_ssl(mtls_config)
    
    logger.info("ðŸš€ Starting Enterprise Nervous System (Secure Mode)")
    
    uvicorn.run(
        "main:app", 
        host="0.0.0.0", 
        port=8011, 
        reload=True,
        **ssl_params
    )